package org.example.security;

import java.security.NoSuchAlgorithmException;
import java.util.Arrays;
import java.util.HashSet;
import java.util.Set;
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.TimeUnit;
import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.RepeatedTest;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.params.ParameterizedTest;
import org.junit.jupiter.params.provider.ValueSource;

@DisplayName("SecureCTRDRBGRandom Tests")
class CTRDRBGSecureRandomV2Test {

  private CTRDRBGSecureRandomV2 random;

  @BeforeEach
  void setUp() throws NoSuchAlgorithmException {
    random = new CTRDRBGSecureRandomV2();
  }

  @Test
  @DisplayName("Test basic random number generation")
  void testBasicRandomGeneration() {
    byte[] bytes = new byte[32];
    random.nextBytes(bytes);

    // Verify that not all bytes are zero
    boolean allZeros = true;
    for (byte b : bytes) {
      if (b != 0) {
        allZeros = false;
        break;
      }
    }
    Assertions.assertFalse(allZeros, "Generated bytes should not be all zeros");
  }

  @Test
  @DisplayName("Test algorithm name")
  void testAlgorithmName() {
    Assertions.assertEquals("CTR-DRBG-AES256", random.getAlgorithm());
  }

  @ParameterizedTest
  @ValueSource(ints = {16, 32, 64, 128, 256, 512, 1024})
  @DisplayName("Test different output sizes")
  void testDifferentOutputSizes(int size) {
    byte[] bytes = new byte[size];
    Assertions.assertDoesNotThrow(() -> random.nextBytes(bytes));
  }

  @Test
  @DisplayName("Test null input handling")
  void testNullInput() {
    Assertions.assertThrows(IllegalArgumentException.class,
        () -> random.nextBytes(null));
  }

  @Test
  @DisplayName("Test exceeding maximum request size")
  void testExceedMaxRequestSize() {
    byte[] tooLarge = new byte[1 << 17]; // Larger than MAX_BYTES_PER_REQUEST
    Assertions.assertThrows(IllegalArgumentException.class,
        () -> random.nextBytes(tooLarge));
  }

  @RepeatedTest(5)
  @DisplayName("Test statistical properties")
  void testStatisticalProperties() {
    byte[] bytes = new byte[10000];
    random.nextBytes(bytes);

    // Calculate basic statistics
    int[] frequencies = new int[256];
    for (byte b : bytes) {
      frequencies[b & 0xFF]++;
    }

    // Chi-square test for uniformity
    double expectedFrequency = bytes.length / 256.0;
    double chiSquare = 0.0;
    for (int frequency : frequencies) {
      double diff = frequency - expectedFrequency;
      chiSquare += (diff * diff) / expectedFrequency;
    }

    // For 255 degrees of freedom at 0.001 significance level
    double criticalValue = 327.86;
    Assertions.assertTrue(chiSquare < criticalValue,
        "Chi-square test failed: " + chiSquare);
  }

  @Test
  @DisplayName("Test reseed functionality")
  void testReseed() {
    // Generate initial sequence
    byte[] sequence1 = new byte[32];
    random.nextBytes(sequence1);

    // Reseed and generate new sequence
    random.reseed();
    byte[] sequence2 = new byte[32];
    random.nextBytes(sequence2);

    Assertions.assertFalse(Arrays.equals(sequence1, sequence2),
        "Sequences should be different after reseed");
  }

  @Test
  @DisplayName("Test concurrent access")
  void testConcurrentAccess() throws InterruptedException {
    int threadCount = 10;
    int iterationsPerThread = 100;
    ExecutorService executor = Executors.newFixedThreadPool(threadCount);
    CountDownLatch latch = new CountDownLatch(threadCount);
    Set<String> results = new HashSet<>();

    for (int i = 0; i < threadCount; i++) {
      executor.submit(() -> {
        try {
          for (int j = 0; j < iterationsPerThread; j++) {
            byte[] bytes = new byte[16];
            random.nextBytes(bytes);
            synchronized (results) {
              results.add(Arrays.toString(bytes));
            }
          }
        } finally {
          latch.countDown();
        }
      });
    }

    boolean completed = latch.await(30, TimeUnit.SECONDS);
    executor.shutdown();

    Assertions.assertTrue(completed, "All threads should complete");
    Assertions.assertEquals(threadCount * iterationsPerThread, results.size(),
        "All generated sequences should be unique");
  }

  @Test
  @DisplayName("Test custom personalization string")
  void testCustomPersonalization() throws NoSuchAlgorithmException {
    byte[] personalization = new byte[32];
    Arrays.fill(personalization, (byte) 42);

    CTRDRBGSecureRandomV2 random1 = new CTRDRBGSecureRandomV2(personalization);
    CTRDRBGSecureRandomV2 random2 = new CTRDRBGSecureRandomV2(personalization);

    byte[] output1 = new byte[32];
    byte[] output2 = new byte[32];

    random1.nextBytes(output1);
    random2.nextBytes(output2);

    // Even with same personalization, outputs should be different
    Assertions.assertFalse(Arrays.equals(output1, output2));
  }

  @Test
  @DisplayName("Test invalid personalization string length")
  void testInvalidPersonalizationLength() {
    byte[] tooLongPersonalization = new byte[236]; // Exceeds MAX_PERSONALIZATION_LENGTH
    Assertions.assertThrows(IllegalArgumentException.class,
        () -> new CTRDRBGSecureRandomV2(tooLongPersonalization));
  }

  @Test
  @DisplayName("Test bytes generated since reseed")
  void testBytesGeneratedSinceReseed() {
    byte[] bytes = new byte[100];
    random.nextBytes(bytes);

    long bytesGenerated = random.getBytesGeneratedSinceReseed();
    Assertions.assertEquals(100, bytesGenerated);

    random.reseed();
    Assertions.assertEquals(0, random.getBytesGeneratedSinceReseed());
  }

  @Test
  @DisplayName("Test destroy functionality")
  void testDestroy() {
    random.destroy();
    Assertions.assertTrue(random.isReseedRequired());
  }

  @Test
  @DisplayName("Test sequential generation")
  void testSequentialGeneration() {
    Set<String> sequences = new HashSet<>();
    for (int i = 0; i < 1000; i++) {
      byte[] bytes = new byte[16];
      random.nextBytes(bytes);
      sequences.add(Arrays.toString(bytes));
    }

    // All sequences should be unique
    Assertions.assertEquals(1000, sequences.size(),
        "All generated sequences should be unique");
  }
}

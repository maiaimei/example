package org.example.security;

import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertFalse;
import static org.junit.jupiter.api.Assertions.assertNotNull;

import java.security.SecureRandom;
import java.util.Arrays;
import lombok.extern.slf4j.Slf4j;
import org.junit.jupiter.api.Test;

@Slf4j
public class CTRDRBGSecureRandomTest {

  @Test
  public void testBasicUsage() {
    SecureRandom secureRandom = new CTRDRBGSecureRandom();
    log.info("Algorithm: {}, Provider: {}", secureRandom.getAlgorithm(), secureRandom.getProvider());
    byte[] randomBytes = new byte[16];
    secureRandom.nextBytes(randomBytes);
    assertNotNull(randomBytes);
  }

  @Test
  void testRandomBytesAreUnique() {
    // Create an instance of CTRDRBGSecureRandom
    CTRDRBGSecureRandom secureRandom = new CTRDRBGSecureRandom();

    // Generate two sets of random bytes
    byte[] randomBytes1 = new byte[32]; // 256 bits
    byte[] randomBytes2 = new byte[32]; // 256 bits

    secureRandom.nextBytes(randomBytes1);
    secureRandom.nextBytes(randomBytes2);

    // Assert that the two byte arrays are not equal
    assertFalse(Arrays.equals(randomBytes1, randomBytes2), "Random bytes should not be the same");
  }

  @Test
  void testRandomBytesLength() {
    // Create an instance of CTRDRBGSecureRandom
    CTRDRBGSecureRandom secureRandom = new CTRDRBGSecureRandom();

    // Generate random bytes of a specific length
    byte[] randomBytes = new byte[64]; // 512 bits
    secureRandom.nextBytes(randomBytes);

    // Assert that the generated byte array has the correct length
    assertEquals(64, randomBytes.length, "Generated byte array should have the correct length");
  }

  @Test
  void testRandomBytesAreConsistentAcrossCalls() {
    // Create an instance of CTRDRBGSecureRandom
    CTRDRBGSecureRandom secureRandom = new CTRDRBGSecureRandom();

    // Generate random bytes multiple times and ensure they are unique
    byte[] previousBytes = new byte[32];
    secureRandom.nextBytes(previousBytes);

    for (int i = 0; i < 10; i++) {
      byte[] currentBytes = new byte[32];
      secureRandom.nextBytes(currentBytes);

      // Assert that the current bytes are not equal to the previous bytes
      assertFalse(Arrays.equals(previousBytes, currentBytes), "Random bytes should not repeat across calls");

      // Update the previous bytes for the next iteration
      previousBytes = currentBytes;
    }
  }

}
